# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2023-12-20T13:18:52+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, Extra, Field, confloat, constr


class AnnotationModel(BaseModel):
    start: int = Field(..., title='Start')
    end: int = Field(..., title='End')
    start_char: int = Field(..., title='Start Char')
    end_char: int = Field(..., title='End Char')
    code: str = Field(..., title='Code')
    text: str = Field(..., title='Text')
    references: List[str] = Field(..., title='References')
    detail: Optional[str] = Field(..., title='Detail')
    suggest: Optional[str] = Field(..., title='Suggest')


class AnnotationStats(BaseModel):
    num_tokens: int = Field(..., title='Num Tokens')
    num_sentences: int = Field(..., title='Num Sentences')
    num_parsed: int = Field(..., title='Num Parsed')
    num_chars: int = Field(..., title='Num Chars')
    ambiguity: float = Field(..., title='Ambiguity')


class AuthToken(BaseModel):
    class Config:
        extra = Extra.forbid

    token: str = Field(..., description='Token value.', title='Token')
    expires_at: Optional[datetime] = Field(
        None, description='Expiration timestamp for token.', title='Expires At'
    )


class ClearHistoryAction(Enum):
    clear = 'clear'
    clear_all = 'clear_all'


class ClearHistoryInput(BaseModel):
    class Config:
        extra = Extra.forbid

    url: Optional[AnyUrl] = Field(
        'https://greynir.is/', description='Query service URL to use.', title='Url'
    )
    action: ClearHistoryAction
    client_id: str = Field(
        ..., description='Unique identifier for the client.', title='Client Id'
    )


class GrammarRequestOptions(BaseModel):
    annotate_unparsed_sentences: Optional[bool] = Field(
        True,
        description="Deprecated. By default, sentences that fail parsing are annotated as containing errors. Setting this option to False is the same as setting 'E001' into 'ignore_rules'.",
        title='Annotate Unparsed Sentences',
    )
    suppress_suggestions: Optional[bool] = Field(
        False,
        description='Suppress less likely suggestions',
        title='Suppress Suggestions',
    )
    ignore_words: Optional[List[str]] = Field(
        [],
        description='Not yet implemented.\nDo not attempt to correct spelling on these words.',
        title='Ignore Words',
    )
    ignore_rules: Optional[List[str]] = Field(
        [],
        description='Do not report errors detected by these rules.',
        title='Ignore Rules',
    )
    custom: Optional[str] = Field(
        '', description='Use a set of custom settings.', title='Custom'
    )
    readability_analysis: Optional[bool] = Field(
        False, description='Analyze readability of text.', title='Readability Analysis'
    )
    rare_word_analysis: Optional[bool] = Field(
        False, description='Report on rare words in text.', title='Rare Word Analysis'
    )


class HTTPErrorOutput(BaseModel):
    detail: str = Field(..., title='Detail')


class LANGS(Enum):
    is_ = 'is'
    en = 'en'
    fo = 'fo'
    pl = 'pl'


class LangPairInfo(BaseModel):
    src: str = Field(..., title='Src')
    tgt: str = Field(..., title='Tgt')
    availableModels: List[str] = Field(..., title='Availablemodels')
    defaultModel: Optional[str] = Field(..., title='Defaultmodel')


class LanguageInfo(BaseModel):
    language: Optional[str] = Field('en', description='Language code', title='Language')


class LanguageResponseData(BaseModel):
    languages: List[LanguageInfo] = Field(
        ..., description='List of available languages', title='Languages'
    )


class QueryOptions(BaseModel):
    class Config:
        extra = Extra.forbid

    url: Optional[AnyUrl] = Field(
        'https://greynir.is/', description='Query service URL to use.', title='Url'
    )
    client_id: Optional[constr(max_length=256)] = Field(
        None, description='Unique identifier for the client.', title='Client Id'
    )
    client_type: Optional[constr(max_length=80)] = Field(
        None, description='Client type.', title='Client Type'
    )
    client_version: Optional[constr(max_length=10)] = Field(
        None, description='Client version.', title='Client Version'
    )
    latitude: Optional[confloat(ge=-90.0, le=90.0)] = Field(
        None, description='Latitude of client when query is made.', title='Latitude'
    )
    longitude: Optional[confloat(ge=-180.0, le=180.0)] = Field(
        None, description='Longitude of client when query is made.', title='Longitude'
    )


class QueryOutput(BaseModel):
    class Config:
        extra = Extra.allow

    answer: Optional[str] = Field(
        None, description='Textual answer to query.', title='Answer'
    )
    error: Optional[str] = Field(
        None, description='Error from query service.', title='Error'
    )
    audio: Optional[str] = Field(
        None, description='URL pointing to speech synthesized answer.', title='Audio'
    )
    key: Optional[str] = Field(
        None, description='Key information in query/answer.', title='Key'
    )
    source: Optional[str] = Field(
        None, description='Source for the query answer.', title='Source'
    )
    image: Optional[str] = Field(
        None, description='Link to image to display.', title='Image'
    )
    command: Optional[str] = Field(
        None, description='Javascript payload.', title='Command'
    )
    open_url: Optional[str] = Field(
        None, description='URL for client to open.', title='Open Url'
    )
    num_parsed_sent: Optional[int] = Field(
        None, description='Number of parsed sentences.', title='Num Parsed Sent'
    )
    num_sent: Optional[int] = Field(
        None, description='Number of sentences.', title='Num Sent'
    )
    q: Optional[str] = Field(None, description='Beautified query.', title='Q')
    q_raw: Optional[str] = Field(None, description='Raw query.', title='Q Raw')
    qtype: Optional[str] = Field(
        None, description='Inferred type of query.', title='Qtype'
    )
    response: Optional[Any] = Field(
        None, description='Additional data in query answer.', title='Response'
    )
    valid: Optional[bool] = Field(
        None, description='Whether the query was valid or not.', title='Valid'
    )
    voice: Optional[str] = Field(
        None,
        description='Phonetically transcribed answer (sent to TTS).',
        title='Voice',
    )
    voice_id: Optional[str] = Field(
        None, description='ID/Name of TTS voice used.', title='Voice Id'
    )
    voice_locale: Optional[str] = Field(
        None, description='Locale of TTS voice.', title='Voice Locale'
    )


class ReadabilityStats(BaseModel):
    flesch_kincaid_score: float = Field(..., title='Flesch Kincaid Score')
    flesch_kincaid_feedback: str = Field(..., title='Flesch Kincaid Feedback')


class ServerSettingsV2(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Optional[str] = Field(
        'Ratatoskur', description='Software name.', title='Name'
    )
    version: Optional[str] = Field(
        '1.3.0', description='Software version.', title='Version'
    )
    author: Optional[str] = Field(
        'Miðeind ehf.', description='Software author.', title='Author'
    )
    copyright: Optional[str] = Field(
        '(C) 2023 Miðeind ehf.', description='Software copyright.', title='Copyright'
    )
    asr: Optional[Dict[str, Any]] = Field(
        {
            'bit_rate': 16,
            'channels': 1,
            'engine': 'azure',
            'format': 'pcm',
            'language': 'is-IS',
            'long_running': False,
            'max_alternatives': 10,
            'sample_rate': 16000,
        },
        description='Defaults and available options for ASR.',
        title='Asr',
    )
    query: Optional[Dict[str, Any]] = Field(
        {}, description='Defaults and available options for querying.', title='Query'
    )
    tts: Optional[Dict[str, Any]] = Field(
        {
            'audio_format': 'mp3',
            'available_voices': {
                'Abbi': {
                    'id': 'en-GB-AbbiNeural',
                    'lang': 'en-GB',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Abril': {
                    'id': 'es-ES-AbrilNeural',
                    'lang': 'es-ES',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Agnieszka': {
                    'id': 'pl-PL-AgnieszkaNeural',
                    'lang': 'pl-PL',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Alain': {
                    'id': 'fr-FR-AlainNeural',
                    'lang': 'fr-FR',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Alfie': {
                    'id': 'en-GB-AlfieNeural',
                    'lang': 'en-GB',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Alvaro': {
                    'id': 'es-ES-AlvaroNeural',
                    'lang': 'es-ES',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Brandon': {
                    'id': 'en-US-BrandonNeural',
                    'lang': 'en-US',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Brigitte': {
                    'id': 'fr-FR-BrigitteNeural',
                    'lang': 'fr-FR',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Christel': {
                    'id': 'da-DK-ChristelNeural',
                    'lang': 'da-DK',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Conrad': {
                    'id': 'de-DE-ConradNeural',
                    'lang': 'de-DE',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Dora': {
                    'id': 'Dora',
                    'lang': 'is-IS',
                    'service': 'AWS Polly',
                    'style': 'female',
                },
                'Elke': {
                    'id': 'de-DE-ElkeNeural',
                    'lang': 'de-DE',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Finn': {
                    'id': 'nb-NO-FinnNeural',
                    'lang': 'nb-NO',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Gudrun': {
                    'id': 'is-IS-GudrunNeural',
                    'lang': 'is-IS',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Gunnar': {
                    'id': 'is-IS-GunnarNeural',
                    'lang': 'is-IS',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Iselin': {
                    'id': 'nb-NO-IselinNeural',
                    'lang': 'nb-NO',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Jenny': {
                    'id': 'en-US-JennyNeural',
                    'lang': 'en-US',
                    'service': 'Azure',
                    'style': 'female',
                },
                'Jeppe': {
                    'id': 'da-DK-JeppeNeural',
                    'lang': 'da-DK',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Karl': {
                    'id': 'Karl',
                    'lang': 'is-IS',
                    'service': 'AWS Polly',
                    'style': 'male',
                },
                'Marek': {
                    'id': 'pl-PL-MarekNeural',
                    'lang': 'pl-PL',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Mattias': {
                    'id': 'sv-SE-MattiasNeural',
                    'lang': 'sv-SE',
                    'service': 'Azure',
                    'style': 'male',
                },
                'Sofie': {
                    'id': 'sv-SE-SofieNeural',
                    'lang': 'sv-SE',
                    'service': 'Azure',
                    'style': 'female',
                },
            },
            'speed': 1.0,
            'text_format': 'ssml',
            'transcription_options': {
                'amounts': True,
                'dates': True,
                'domains': True,
                'emails': True,
                'measurements': True,
                'numbers': False,
                'ordinals': False,
                'percentages': True,
                'urls': True,
                'years': True,
            },
            'voice': 'Gudrun',
        },
        description='Defaults and available options for TTS.',
        title='Tts',
    )


class TTSOptionsV1(BaseModel):
    class Config:
        extra = Extra.forbid

    voice_id: Optional[str] = Field(
        'Gudrun', description='Name of voice for speech synthesis.', title='Voice Id'
    )
    voice_speed: Optional[confloat(ge=0.5, le=2.0)] = Field(
        1.0, description='Speed of the synthesized speech.', title='Voice Speed'
    )


class TTSOutput(BaseModel):
    class Config:
        extra = Extra.forbid

    audio_url: str = Field(..., description='URL of audio file.', title='Audio Url')
    text: Optional[str] = Field(
        None,
        description='Text after transcription, if any was performed.',
        title='Text',
    )


class TextFormats(Enum):
    ssml = 'ssml'
    text = 'text'


class TokenModel(BaseModel):
    kind: Optional[int] = Field(None, description='Token kind', title='Kind')
    text: Optional[str] = Field(None, description='Corrected token text', title='Text')
    original: Optional[str] = Field(
        None, description='Original token text', title='Original'
    )
    i: Optional[int] = Field(
        None,
        description='Character offset of token, indexed from the start of the checked text',
        title='Offset',
    )


class TranscriptionOptions(BaseModel):
    class Config:
        extra = Extra.forbid

    emails: Optional[bool] = Field(
        True, description='Whether to transcribe emails.', title='Emails'
    )
    dates: Optional[bool] = Field(
        True, description='Whether to transcribe dates.', title='Dates'
    )
    years: Optional[bool] = Field(
        True, description='Whether to transcribe years.', title='Years'
    )
    domains: Optional[bool] = Field(
        True, description='Whether to transcribe domains.', title='Domains'
    )
    urls: Optional[bool] = Field(
        True, description='Whether to transcribe URLs.', title='Urls'
    )
    amounts: Optional[bool] = Field(
        True,
        description='Whether to transcribe amounts (number with currency).',
        title='Amounts',
    )
    measurements: Optional[bool] = Field(
        True,
        description='Whether to transcribe measurements (number with unit of measurement).',
        title='Measurements',
    )
    percentages: Optional[bool] = Field(
        True, description='Whether to transcribe percentages.', title='Percentages'
    )
    numbers: Optional[bool] = Field(
        False, description='Whether to transcribe (cardinal) numbers.', title='Numbers'
    )
    ordinals: Optional[bool] = Field(
        False, description='Whether to transcribe ordinal numbers.', title='Ordinals'
    )


class TranslationCorrectionData(BaseModel):
    originalText: str = Field(..., title='Originaltext')
    machineTranslatedText: Optional[str] = Field(..., title='Machinetranslatedtext')
    correctedText: str = Field(..., title='Correctedtext')
    translationReference: Optional[int] = Field(..., title='Translationreference')
    languagePair: str = Field(..., title='Languagepair')
    model: Optional[str] = Field(..., title='Model')
    userReference: Optional[str] = Field(..., title='Userreference')


class TranslationModelInfo(BaseModel):
    availableModels: List[str] = Field(..., title='Availablemodels')
    availableLangPairs: List[LangPairInfo] = Field(..., title='Availablelangpairs')


class TranslationRequestData(BaseModel):
    contents: Optional[List[str]] = Field(
        [
            'Where is the museum? I want to buy bread and milk. I should buy a boat.',
            'This fundamental plant growth research is also a key example of how Nasa is working to unlock agricultural innovations that could help us understand how plants might overcome stressful conditions in food-scarce areas here on Earth.',
            'Look on my works, ye mighty, and despair!',
            '“You know,” said Arthur, “it’s at times like this, when I’m trapped in a Vogon airlock with a man from Betelgeuse, and about to die of asphyxiation in deep space that I really wish I’d listened to what my mother told me when I was young.” “Why, what did she tell you?” “I don’t know, I didn’t listen.”',
        ],
        description='Text to translate',
        title='Contents',
    )
    sourceLanguageCode: Optional[LANGS] = Field(
        'en', description='The source language to translate from'
    )
    targetLanguageCode: Optional[LANGS] = Field(
        'is', description='The target language to translate into'
    )
    model: Optional[str] = Field(
        None, description='Translation model to use', title='Model'
    )
    domain: Optional[str] = Field(
        '',
        description='Translate text in this domain. Ignored for non-domain-aware models.',
        title='Domain',
    )


class TranslationResponseData(BaseModel):
    translations: Optional[List] = Field(
        [
            {
                'translatedText': 'Hvar er safnið? Ég vil kaupa brauð og mjólk. Ég ætti að kaupa bát.',
                'translatedTextStructured': [
                    ['Where is the museum?', 'Hvar er safnið?'],
                    ['I want to buy bread and milk.', 'Ég vil kaupa brauð og mjólk.'],
                    ['I should buy a boat.', 'Ég ætti að kaupa bát.'],
                ],
            },
            {
                'translatedText': 'Ég er setning tvö.',
                'translatedTextStructured': [
                    ['I am sentence two.', 'Ég er setning tvö.']
                ],
            },
        ],
        description='Results from translation. Results contain both the entire translated text and also the text broken down into sentences as processed by the translation system.',
        title='Translations',
    )
    sourceLanguageCode: Optional[LANGS] = Field(
        'en', description='The source language code used for translation'
    )
    targetLanguageCode: Optional[LANGS] = Field(
        'is', description='The target language code used for translation'
    )
    model: Optional[str] = Field(
        'mbart-multi-doc', description='The model used for translation', title='Model'
    )


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class AnnotatedSentenceModel(BaseModel):
    original: str = Field(..., title='Original')
    tokens: List[TokenModel] = Field(..., title='Tokens')
    annotations: List[AnnotationModel] = Field(..., title='Annotations')
    corrected: str = Field(..., title='Corrected')


class GrammarRequestData(BaseModel):
    text: Optional[str] = Field(
        'Jón sagði: "Mér langar í ís." Anna sklidi eki hvenrig Jón gat borðað sovna mikin ís. Sem betur fer var ísbúð á næsta leyti.',
        description='Text to examine',
        title='Text',
    )
    options: Optional[GrammarRequestOptions]


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title='Detail')


class QueryInput(BaseModel):
    class Config:
        extra = Extra.forbid

    q: str = Field(
        ..., description='Query or multiple queries separated by `|`.', title='Q'
    )
    options: Optional[QueryOptions] = None
    tts: Optional[bool] = Field(
        True, description='If true, query answer is sent to TTS service.', title='Tts'
    )
    tts_options: Optional[TTSOptionsV1] = None


class TTSInputV1(BaseModel):
    class Config:
        extra = Extra.forbid

    text: str = Field(..., description='Text to be synthesized.', title='Text')
    options: Optional[TTSOptionsV1] = None


class TTSOptions(BaseModel):
    class Config:
        extra = Extra.forbid

    voice: Optional[str] = Field(
        'Gudrun', description='Speech synthesis voice.', title='Voice'
    )
    speed: Optional[confloat(ge=0.5, le=2.0)] = Field(
        1.0, description='TTS speed.', title='Speed'
    )
    text_format: Optional[TextFormats] = Field(
        'ssml', description='Format of text (plaintext or SSML).'
    )
    audio_format: Optional[str] = Field(
        'mp3', description='Audio format for TTS output.', title='Audio Format'
    )


class AnnotatedParagraphModel(BaseModel):
    sentences: List[AnnotatedSentenceModel] = Field(..., title='Sentences')
    total_tokens: int = Field(..., title='Total Tokens')


class GrammarResponseData(BaseModel):
    paragraphs: List[AnnotatedParagraphModel] = Field(..., title='Paragraphs')
    stats: AnnotationStats
    text: str = Field(..., title='Text')
    valid: bool = Field(..., title='Valid')
    readability_stats: Optional[ReadabilityStats]
    rare_words: Optional[List[str]] = Field(..., title='Rare Words')


class TTSInputV2(BaseModel):
    class Config:
        extra = Extra.forbid

    text: str = Field(..., description='Text to be synthesized.', title='Text')
    tts_options: Optional[TTSOptions] = None
    transcribe: Optional[bool] = Field(
        True,
        description='Set to True to enable transcription, False to disable.',
        title='Transcribe',
    )
    transcription_options: Optional[TranscriptionOptions] = Field(
        None, description='Options for transcription.'
    )
